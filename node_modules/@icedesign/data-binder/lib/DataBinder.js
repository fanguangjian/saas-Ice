'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = dataBinder;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _pureRenderDecorator = require('pure-render-decorator');

var _pureRenderDecorator2 = _interopRequireDefault(_pureRenderDecorator);

var _deepmerge = require('deepmerge');

var _deepmerge2 = _interopRequireDefault(_deepmerge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var Feedback = require('@icedesign/base/lib/feedback');

var Toast = Feedback.toast;

/**
 * DataBinder 的 HOC 创建函数，预先做一些数据整理
 *
 * @param  {Object} options 为各个模块的 DataSource 配置，详情参见 README.md 和 Demo
 * @return {function}
 */
function dataBinder(options) {
  var requestOptions = {};
  var defaultBindingDatas = {
    __loading: false,
    __error: null
  };

  // 根据传入数据进行初始化
  Object.keys(options).forEach(function (dataSourceKey) {
    var _options$dataSourceKe = options[dataSourceKey],
        _options$dataSourceKe2 = _options$dataSourceKe.defaultBindingData,
        defaultBindingData = _options$dataSourceKe2 === undefined ? {} : _options$dataSourceKe2,
        others = _objectWithoutProperties(_options$dataSourceKe, ['defaultBindingData']);

    defaultBindingDatas[dataSourceKey] = defaultBindingData;
    defaultBindingDatas[dataSourceKey].__loading = false; // eslint-disable-line
    defaultBindingDatas[dataSourceKey].__error = null; // eslint-disable-line
    requestOptions[dataSourceKey] = others;
  });

  /**
   * Core HOC 函数
   *
   * @param  {ReactElement} WrappedComponent 被包裹的 React Element
   * @return {ReactElement}                  IceDataBinderWrapper React Element
   */
  return function dataBinderHOC(WrappedComponent) {
    var _class, _class2, _temp;

    return (0, _pureRenderDecorator2.default)(_class = (_temp = _class2 = function (_Component) {
      _inherits(IceDataBinderWrapper, _Component);

      function IceDataBinderWrapper(props) {
        _classCallCheck(this, IceDataBinderWrapper);

        // state 默认包含所有的 DataSource 中的 defaultBindingData 数据
        var _this = _possibleConstructorReturn(this, (IceDataBinderWrapper.__proto__ || Object.getPrototypeOf(IceDataBinderWrapper)).call(this, props));

        _this.updateStateWithDataSource = function (dataSourceKey, originDatas, newData, _ref) {
          var _ref$__loading = _ref.__loading,
              __loading = _ref$__loading === undefined ? false : _ref$__loading,
              _ref$__error = _ref.__error,
              __error = _ref$__error === undefined ? null : _ref$__error;

          var tmpObj = {};
          tmpObj[dataSourceKey] = _extends({}, originDatas[dataSourceKey], newData, {
            __loading: __loading,
            __error: __error
          });

          _this.setState(_extends({}, _this.state, {
            __loading: __loading,
            __error: __error
          }, tmpObj));
        };

        _this.updateBindingData = function (dataSourceKey) {
          var newDataSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var callback = arguments[2];

          if (!dataSourceKey && typeof dataSourceKey !== 'string') {
            console.error('必须指明一个 dataSourceKey，并且值类型为 String。');
            return;
          }

          var newRequestOptions = (0, _deepmerge2.default)(
          // 参数每次跟初始化的配置进行 merge
          requestOptions[dataSourceKey], newDataSource);

          // 如果更新时同时附带 defaultBindingData 则先同步更新一次数据，再请求更新
          // 没有 url 配置走同步修改逻辑，只修改 DataSource defaultBindingData 的数据，不进行异步请求
          if (!newRequestOptions.url) {
            if (newDataSource.defaultBindingData) {
              _this.updateStateWithDataSource(dataSourceKey, defaultBindingDatas, newDataSource.defaultBindingData, {});
            } else {
              console.error('要更新的 DataSource 必须要有一个 url 或者 defaultBindingData 配置。');
            }

            return;
          }

          // 这里只需要改变模块的 __loading 属性，不涉及数据 merge
          // 因此要获取当前最新的 state 否则界面会突然切换回默认数据，然后再生效
          _this.updateStateWithDataSource(dataSourceKey, _this.state, newDataSource.defaultBindingData, { __loading: true });

          var customSuccess = newRequestOptions.success;
          var customError = newRequestOptions.error;
          var defaultErrorCallback = function defaultErrorCallback() {
            Toast.error('网络问题，请稍后重试！');
          };

          (0, _axios2.default)(_extends({}, newRequestOptions))
          // network error
          .catch(function (err) {
            // eslint-disable-next-line
            var __error = {
              message: '网络问题，请稍后重试！'
            };

            _this.updateStateWithDataSource(dataSourceKey, defaultBindingDatas, (err.response || {}).data || {}, { __loading: false, __error: __error });

            if (customError) {
              customError(err.response, defaultErrorCallback, err);
            } else {
              // 如果没有自定义回调，那么就执行默认的 callback 提示
              defaultErrorCallback();
            }

            if (typeof callback === 'function') {
              callback(err.response, err);
            }
          }).then(function (res) {
            var responseHandler = function responseHandler(responseData, originResponse) {
              if (!responseData.data) {
                console.error('警告：接口必须返回一个 data 字段作为新数据！如果接口无法改动，请配置 responseFormatter 进行数据格式调整！');
                responseData.data = {};
              }

              // eslint-disable-next-line
              var __error = null;

              // 兼容 status: "SUCCESS" 和 success: true 的情况
              if (responseData.status === 'SUCCESS' || responseData.success) {
                var defaultCallback = function defaultCallback() {
                  if (responseData.message) {
                    Toast.success(responseData.message);
                  }
                };

                if (customSuccess) {
                  // 传递 defaultCallback 第二个参数是为了让用户可以在现有默认逻辑上执行其他
                  // 自定义逻辑
                  customSuccess(responseData, defaultCallback, originResponse);
                } else {
                  defaultCallback();
                }
              } else {
                __error = {
                  message: responseData.message
                };

                var _defaultCallback = function _defaultCallback() {
                  if (responseData.message) {
                    Toast.error(responseData.message);
                  }
                };

                // 这里的 success 是请求成功的意思，并不表示业务逻辑执行成功
                if (customSuccess) {
                  customSuccess(responseData, _defaultCallback, originResponse);
                } else {
                  _defaultCallback();
                }
              }

              // 更新数据重新渲染，不确定失败的情况下是否要更新
              // 但是失败可能需要某些状态来显示报错信息，所以保留了
              _this.updateStateWithDataSource(dataSourceKey, defaultBindingDatas, responseData.data, { __loading: false, __error: __error });
            };

            userFormatterIfExist(newRequestOptions.responseFormatter, responseHandler, res.data, res);

            if (typeof callback === 'function') {
              callback(res.data, res);
            }
          });
        };

        _this.getDataSource = function (dataSourceKey) {
          return options[dataSourceKey];
        };

        _this.state = _extends({}, defaultBindingDatas);
        return _this;
      }

      /**
       * 更新某个 DataSource 的数据，混合原始数据、新数据来更新
       *
       * @private
       * @param  {String} dataSourceKey 要更新的 DataSource key
       * @param  {Object} originDatas   等待被更新的所有 DataSource 数据
       * @param  {Object} newData       新的 DataSource 数据
       * @return undefined
       */


      /**
       * 传递参数更新当前 DataSource 数据
       *
       * @param  {String}   dataSourceKey      当前 DataSource 模块 dataSourceKey
       * @param  {Object}   newDataSource   更新的数据，会和默认的 Data 进行 merge 然后触发 AJAX
       * @param  {Function} callback 请求完成的回调方法
       * @return undefined
       */


      _createClass(IceDataBinderWrapper, [{
        key: 'render',
        value: function render() {
          return _react2.default.createElement(WrappedComponent, _extends({}, this.props, {
            getDataSource: this.getDataSource,
            updateBindingData: this.updateBindingData,
            bindingData: this.state
          }));
        }
      }]);

      return IceDataBinderWrapper;
    }(_react.Component), _class2.displayName = 'IceDataBinderWrapper(' + getDisplayName(WrappedComponent) + ')', _temp)) || _class;
  };
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}
function userFormatterIfExist(funca, funcb, responseData, originResponse) {
  if (funca) {
    funca(funcb, responseData, originResponse);
  } else {
    funcb(responseData, originResponse);
  }
}
module.exports = exports['default'];